import telebot
from typing import List, Dict
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from datetime import datetime
from discord_telegram_parser.models.message import Message
from discord_telegram_parser.config.settings import config
import json
import os
import time
import threading
import asyncio
from loguru import logger

class TelegramBotService:
    def __init__(self, bot_token: str):
        self.bot = telebot.TeleBot(bot_token)
        self.bot.skip_pending = True
        self.bot.threaded = True
        self.network_timeout = 30
        self.message_store = 'telegram_messages.json'
        self.user_states = {}
        self.server_topics = {}  # server_name -> topic_id mapping
        self.topic_name_cache = {}  # topic_id -> server_name mapping –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        self.websocket_service = None
        self.topic_creation_lock = threading.Lock()
        
        # –ù–æ–≤—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–µ–π
        self.startup_verification_done = False
        self.topic_sync_lock = threading.Lock()
        
        # Load existing data
        self._load_data()
    
    def _load_data(self):
        """Load message mappings and topic mappings"""
        if os.path.exists(self.message_store):
            try:
                with open(self.message_store, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.message_mappings = data.get('messages', {})
                    self.server_topics = data.get('topics', {})
                    
                    # –°–æ–∑–¥–∞–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π –∫—ç—à –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
                    self.topic_name_cache = {v: k for k, v in self.server_topics.items()}
                    
                    logger.info(f"üìã Loaded {len(self.server_topics)} topic mappings from cache")
            except Exception as e:
                logger.error(f"Error loading data: {e}")
                self.message_mappings = {}
                self.server_topics = {}
                self.topic_name_cache = {}
        else:
            self.message_mappings = {}
            self.server_topics = {}
            self.topic_name_cache = {}

    def _save_data(self):
        """Save message mappings and topic mappings"""
        try:
            with open(self.message_store, 'w', encoding='utf-8') as f:
                json.dump({
                    'messages': self.message_mappings,
                    'topics': self.server_topics
                }, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error saving data: {e}")

    def startup_topic_verification(self, chat_id=None):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–ø–∏–∫–æ–≤ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–µ–π"""
        if self.startup_verification_done:
            return
            
        with self.topic_sync_lock:
            if self.startup_verification_done:  # –î–≤–æ–π–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
                return
                
            chat_id = chat_id or config.TELEGRAM_CHAT_ID
            
            logger.info("üîç Starting startup topic verification to prevent duplicates...")
            
            try:
                if not self._check_if_supergroup_with_topics(chat_id):
                    logger.info("‚ÑπÔ∏è Chat doesn't support topics, skipping verification")
                    self.startup_verification_done = True
                    return
                
                # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–æ–ø–∏–∫–∏ (—á–µ—Ä–µ–∑ –ø–æ–ø—ã—Ç–∫—É –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è)
                existing_valid_topics = {}
                invalid_topics = []
                
                for server_name, topic_id in list(self.server_topics.items()):
                    if self._topic_exists(chat_id, topic_id):
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –¥—É–±–ª–∏ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
                        topic_name = f"üè∞ {server_name}"
                        
                        if topic_name in existing_valid_topics:
                            # –ù–∞–π–¥–µ–Ω –¥—É–±–ª—å! –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ç–æ–ø–∏–∫
                            old_topic_id = existing_valid_topics[topic_name]
                            logger.warning(f"üóëÔ∏è Found duplicate topic for '{server_name}': keeping {topic_id}, closing {old_topic_id}")
                            
                            try:
                                self.bot.close_forum_topic(
                                    chat_id=chat_id,
                                    message_thread_id=old_topic_id
                                )
                                logger.info(f"üîí Closed duplicate topic {old_topic_id}")
                            except Exception as e:
                                logger.warning(f"‚ö†Ô∏è Could not close duplicate topic {old_topic_id}: {e}")
                            
                            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∏–∑ –∫—ç—à–∞
                            for srv_name, srv_topic_id in list(self.server_topics.items()):
                                if srv_topic_id == old_topic_id:
                                    del self.server_topics[srv_name]
                                    break
                        
                        existing_valid_topics[topic_name] = topic_id
                        
                    else:
                        # –¢–æ–ø–∏–∫ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                        invalid_topics.append(server_name)
                
                # –£–¥–∞–ª—è–µ–º –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–æ–ø–∏–∫–∏ –∏–∑ –∫—ç—à–∞
                for server_name in invalid_topics:
                    if server_name in self.server_topics:
                        old_topic_id = self.server_topics[server_name]
                        del self.server_topics[server_name]
                        logger.info(f"üóëÔ∏è Removed invalid topic mapping: {server_name} -> {old_topic_id}")
                
                # –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π –∫—ç—à
                self.topic_name_cache = {v: k for k, v in self.server_topics.items()}
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
                if invalid_topics or len(existing_valid_topics) != len(self.server_topics):
                    self._save_data()
                
                logger.success(f"‚úÖ Startup verification complete:")
                logger.info(f"   üìã Valid topics: {len(self.server_topics)}")
                logger.info(f"   üóëÔ∏è Removed invalid: {len(invalid_topics)}")
                logger.info(f"   üõ°Ô∏è Duplicate protection: ACTIVE")
                
                self.startup_verification_done = True
                
            except Exception as e:
                logger.error(f"‚ùå Error during startup verification: {e}")
                self.startup_verification_done = True

    def _check_if_supergroup_with_topics(self, chat_id):
        """Check if the chat supports topics"""
        try:
            chat = self.bot.get_chat(chat_id)
            return chat.type == 'supergroup' and getattr(chat, 'is_forum', False)
        except Exception as e:
            logger.debug(f"Error checking chat type: {e}")
            return False

    def _topic_exists(self, chat_id, topic_id):
        """Check if a specific topic exists using Telegram API"""
        if not topic_id:
            return False
            
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–ø–∏–∫–µ
            topic_info = self.bot.get_forum_topic(
                chat_id=chat_id,
                message_thread_id=topic_id
            )
            return topic_info is not None and not getattr(topic_info, 'is_closed', False)
        except telebot.apihelper.ApiException as e:
            if "not found" in str(e).lower() or "thread not found" in str(e).lower():
                return False
            # For other errors, assume topic exists
            return True
        except Exception:
            return False

    def get_server_topic_id(self, server_name: str):
        """Get existing topic ID for server (safe for real-time use)"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
        if not self.startup_verification_done:
            self.startup_topic_verification()
        
        # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        if server_name in self.server_topics:
            topic_id = self.server_topics[server_name]
            logger.debug(f"üìç Found cached topic {topic_id} for server '{server_name}'")
            return topic_id
        return None

    def _get_or_create_topic_safe(self, server_name: str, chat_id=None):
        """Thread-safe method to get or create topic for server with duplicate prevention"""
        chat_id = chat_id or config.TELEGRAM_CHAT_ID
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        if not self.startup_verification_done:
            self.startup_topic_verification(chat_id)
        
        # –í–ê–ñ–ù–û: –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –ë–ï–ó –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
        if server_name in self.server_topics:
            cached_topic_id = self.server_topics[server_name]
            
            # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ç–æ–ø–∏–∫–∞
            if self._topic_exists(chat_id, cached_topic_id):
                logger.debug(f"‚úÖ Using existing cached topic {cached_topic_id} for server '{server_name}'")
                return cached_topic_id
            else:
                logger.warning(f"‚ö†Ô∏è Cached topic {cached_topic_id} not found, will recreate")
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å/–ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Ç–æ–ø–∏–∫
        with self.topic_creation_lock:
            # –î–≤–æ–π–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
            if server_name in self.server_topics:
                topic_id = self.server_topics[server_name]
                
                # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
                if self._topic_exists(chat_id, topic_id):
                    logger.debug(f"‚úÖ Using existing topic {topic_id} for server '{server_name}' (double-check)")
                    return topic_id
                else:
                    logger.warning(f"üóëÔ∏è Topic {topic_id} confirmed missing, removing from cache")
                    del self.server_topics[server_name]
                    if topic_id in self.topic_name_cache:
                        del self.topic_name_cache[topic_id]
                    self._save_data()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ª–∏ —á–∞—Ç —Ç–æ–ø–∏–∫–∏
            if not self._check_if_supergroup_with_topics(chat_id):
                logger.info(f"‚ÑπÔ∏è Chat doesn't support topics, using regular messages")
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ —Ç–æ–ø–∏–∫–∞ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞)
            topic_name = f"üè∞ {server_name}"
            for existing_server, existing_topic_id in self.server_topics.items():
                if existing_server != server_name and self._topic_exists(chat_id, existing_topic_id):
                    try:
                        topic_info = self.bot.get_forum_topic(chat_id, existing_topic_id)
                        if topic_info and getattr(topic_info, 'name', '') == topic_name:
                            logger.warning(f"üîç Found existing topic with same name for different server: {existing_server}")
                            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç–æ–ø–∏–∫ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –º–∞–ø–ø–∏–Ω–≥
                            self.server_topics[server_name] = existing_topic_id
                            self.topic_name_cache[existing_topic_id] = server_name
                            self._save_data()
                            return existing_topic_id
                    except:
                        continue
            
            # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —Ç–æ–ø–∏–∫
            logger.info(f"üî® Creating new topic for server '{server_name}'")
            
            try:
                topic = self.bot.create_forum_topic(
                    chat_id=chat_id,
                    name=topic_name,
                    icon_color=0x6FB9F0,  # Blue color
                    icon_custom_emoji_id=None
                )
                
                topic_id = topic.message_thread_id
                self.server_topics[server_name] = topic_id
                self.topic_name_cache[topic_id] = server_name
                self._save_data()
                
                logger.success(f"‚úÖ Created new topic for server '{server_name}' with ID: {topic_id}")
                return topic_id
                
            except Exception as e:
                logger.error(f"‚ùå Error creating topic for server '{server_name}': {e}")
                return None

    def _recreate_topic_if_missing(self, server_name: str, chat_id=None):
        """Recreate a topic if the current one is missing"""
        chat_id = chat_id or config.TELEGRAM_CHAT_ID
        
        # Remove the old topic ID from our mapping
        if server_name in self.server_topics:
            old_topic_id = self.server_topics[server_name]
            logger.info(f"üóëÔ∏è Removing invalid topic {old_topic_id} for server '{server_name}'")
            del self.server_topics[server_name]
            if old_topic_id in self.topic_name_cache:
                del self.topic_name_cache[old_topic_id]
            self._save_data()
        
        # Create a new topic using safe method
        return self._get_or_create_topic_safe(server_name, chat_id)

    def format_message(self, message: Message) -> str:
        """Format message for topic replies"""
        formatted = []
        
        # Add channel info if available
        if message.channel_name:
            formatted.append(f"üì¢ #{message.channel_name}")
        
        if config.TELEGRAM_UI_PREFERENCES['show_timestamps']:
            formatted.append(f"üìÖ {message.timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
        
        formatted.append(f"üë§ {message.author}")
        formatted.append(f"üí¨ {message.content}")
        
        return "\n".join(formatted)

    def send_messages(self, messages: List[Message]):
        """Send formatted messages to Telegram with improved duplicate prevention"""
        if not messages:
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        if not self.startup_verification_done:
            self.startup_topic_verification()
        
        server_groups = {}
        
        # Group messages by server
        for message in messages:
            server_name = message.server_name or "Unknown Server"
            if server_name not in server_groups:
                server_groups[server_name] = []
            server_groups[server_name].append(message)
        
        # Send messages with server topics (NO DUPLICATES!)
        for server_name, server_messages in server_groups.items():
            logger.info(f"üì§ Sending {len(server_messages)} messages for server: {server_name}")
            
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –±—ã—Å—Ç—Ä—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ–ø–∏–∫–æ–≤
            topic_id = self.get_server_topic_id(server_name)
            if not topic_id:
                # –°–æ–∑–¥–∞—ë–º —Ç–æ–ø–∏–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç (—Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–µ–π)
                topic_id = self._get_or_create_topic_safe(server_name)
            
            # Sort messages chronologically (oldest first)
            server_messages.sort(key=lambda x: x.timestamp, reverse=False)
            
            # Send messages in order
            success_count = 0
            for message in server_messages:
                formatted = self.format_message(message)
                sent_msg = self._send_message(
                    formatted,
                    message_thread_id=topic_id,
                    server_name=server_name
                )
                
                if sent_msg:
                    # Store mapping between Discord and Telegram message IDs
                    self.message_mappings[str(message.timestamp)] = sent_msg.message_id
                    success_count += 1
                else:
                    logger.warning(f"‚ùå Failed to send message: {formatted[:50]}...")
            
            logger.info(f"‚úÖ Sent {success_count}/{len(server_messages)} messages for {server_name}")
            
            # Save mappings after each server
            self._save_data()
            
        logger.success(f"‚úÖ Completed sending messages for {len(server_groups)} servers")

    def _send_message(self, text: str, chat_id=None, message_thread_id=None, server_name=None):
        """Send message to topic or regular chat with error recovery and duplicate prevention"""
        chat_id = chat_id or config.TELEGRAM_CHAT_ID
        max_retries = 3
        retry_delay = 5
        
        logger.debug(f"üì§ Sending message to chat {chat_id}")
        if message_thread_id:
            logger.debug(f"üìç Topic: {message_thread_id}")
            
        for chunk in [text[i:i+4000] for i in range(0, len(text), 4000)]:
            for attempt in range(max_retries):
                try:
                    result = self.bot.send_message(
                        chat_id, 
                        chunk,
                        message_thread_id=message_thread_id
                    )
                    logger.debug(f"‚úÖ Message sent successfully: {result.message_id}")
                    return result
                    
                except Exception as e:
                    error_str = str(e)
                    logger.warning(f"‚ùå Error sending message (attempt {attempt + 1}): {e}")
                    
                    # Handle specific error cases
                    if "message thread not found" in error_str and server_name and message_thread_id:
                        logger.warning(f"üîç Topic {message_thread_id} not found for server '{server_name}'")
                        
                        # Try to recreate the topic (with duplicate prevention)
                        new_topic_id = self._recreate_topic_if_missing(server_name, chat_id)
                        
                        if new_topic_id:
                            logger.info(f"üî® Created new topic {new_topic_id}. Retrying...")
                            message_thread_id = new_topic_id
                            continue  # Retry with new topic ID
                        else:
                            logger.warning("‚ö†Ô∏è Failed to recreate topic. Sending as regular message.")
                            message_thread_id = None  # Fall back to regular message
                            continue
                            
                    elif "message thread not found" in error_str and message_thread_id:
                        logger.warning("‚ö†Ô∏è Topic not found and no server name provided. Falling back to regular message.")
                        message_thread_id = None  # Fall back to regular message
                        continue
                        
                    elif "Too Many Requests" in error_str:
                        wait_time = 60  # Default wait time
                        if "retry after" in error_str:
                            try:
                                wait_time = int(error_str.split("retry after")[1].strip())
                            except:
                                pass
                        logger.warning(f"‚è≥ Rate limited. Waiting {wait_time} seconds...")
                        time.sleep(wait_time)
                        continue
                        
                    elif attempt == max_retries - 1:
                        logger.error(f"üí• Failed to send message after {max_retries} attempts: {e}")
                        return None
                        
                    time.sleep(retry_delay)
            
        return None

    def cleanup_invalid_topics(self, chat_id=None):
        """Clean up invalid topic mappings with duplicate detection"""
        chat_id = chat_id or config.TELEGRAM_CHAT_ID
        
        with self.topic_sync_lock:
            invalid_topics = []
            valid_topics = {}
            
            for server_name, topic_id in list(self.server_topics.items()):
                if not self._topic_exists(chat_id, topic_id):
                    invalid_topics.append(server_name)
                else:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –¥—É–±–ª–∏
                    topic_name = f"üè∞ {server_name}"
                    if topic_name in valid_topics:
                        # –ù–∞–π–¥–µ–Ω –¥—É–±–ª—å, –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π
                        old_topic_id = valid_topics[topic_name]
                        logger.warning(f"üóëÔ∏è Duplicate topic found during cleanup: {server_name}")
                        try:
                            self.bot.close_forum_topic(chat_id, old_topic_id)
                        except:
                            pass
                        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∏–∑ –º–∞–ø–ø–∏–Ω–≥–∞
                        for srv, tid in list(self.server_topics.items()):
                            if tid == old_topic_id:
                                invalid_topics.append(srv)
                                break
                    
                    valid_topics[topic_name] = topic_id
            
            # Remove invalid topics
            for server_name in invalid_topics:
                if server_name in self.server_topics:
                    old_topic_id = self.server_topics[server_name]
                    logger.info(f"üóëÔ∏è Removing invalid topic for server: {server_name} (ID: {old_topic_id})")
                    del self.server_topics[server_name]
                    if old_topic_id in self.topic_name_cache:
                        del self.topic_name_cache[old_topic_id]
            
            if invalid_topics:
                self._save_data()
                logger.success(f"üßπ Cleaned up {len(invalid_topics)} invalid/duplicate topics")
            
            return len(invalid_topics)

    def start_bot(self):
        """Start bot with improved topic management and startup verification"""
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ç–æ–ø–∏–∫–æ–≤ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        self.startup_topic_verification()
        
        @self.bot.message_handler(commands=['start', 'help'])
        def send_welcome(message):
            supports_topics = self._check_if_supergroup_with_topics(message.chat.id)
            
            text = (
                "ü§ñ Welcome to Discord Announcement Parser!\n\n"
                "üî• **Real-time WebSocket Mode** - Instant message delivery!\n"
                "üì° Messages are received via WebSocket for immediate forwarding\n"
                "üõ°Ô∏è **ANTI-DUPLICATE System**: Prevents topic duplication!\n\n"
            )
            
            if supports_topics:
                text += (
                    "üîπ Forum Topics Mode (Enabled):\n"
                    "‚Ä¢ Each Discord server gets ONE topic (NO DUPLICATES)\n"
                    "‚Ä¢ Messages from all channels in server go to same topic\n"
                    "‚Ä¢ Smart caching prevents duplicate topic creation\n"
                    "‚Ä¢ Auto-recovery for missing topics\n"
                    "‚Ä¢ Fast topic lookup for real-time messages\n"
                    "‚Ä¢ Startup verification prevents duplicates on restart\n"
                    "‚Ä¢ Messages displayed chronologically\n\n"
                )
            else:
                text += (
                    "üîπ Regular Messages Mode:\n"
                    "‚Ä¢ Messages sent as regular chat messages\n"
                    "‚Ä¢ To enable topics, convert this chat to a supergroup with topics enabled\n\n"
                )
            
            text += "Choose an action below:"
            
            markup = InlineKeyboardMarkup(row_width=2)
            markup.add(
                InlineKeyboardButton("üìã Server List", callback_data="action_servers"),
                InlineKeyboardButton("üîÑ Manual Sync", callback_data="action_refresh"),
                InlineKeyboardButton("‚ö° WebSocket Status", callback_data="action_websocket"),
                InlineKeyboardButton("üßπ Clean Topics", callback_data="action_cleanup"),
                InlineKeyboardButton("üìä Bot Status", callback_data="action_status"),
                InlineKeyboardButton("‚ÑπÔ∏è Help", callback_data="action_help")
            )
            
            self.bot.send_message(message.chat.id, text, reply_markup=markup)

        @self.bot.callback_query_handler(func=lambda call: call.data.startswith('action_'))
        def handle_action(call):
            action = call.data.replace('action_', '')
            
            if action == 'cleanup':
                cleaned = self.cleanup_invalid_topics(call.message.chat.id)
                markup = InlineKeyboardMarkup()
                markup.add(InlineKeyboardButton("üîô Back to Menu", callback_data="action_start"))
                self.bot.edit_message_text(
                    f"üßπ Topic cleanup completed!\n\n"
                    f"Removed {cleaned} invalid/duplicate topics.\n"
                    f"Current topics: {len(self.server_topics)}\n"
                    f"üõ°Ô∏è Anti-duplicate protection: ACTIVE",
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=markup
                )
            elif action == 'status':
                supports_topics = self._check_if_supergroup_with_topics(call.message.chat.id)
                
                status_text = (
                    "üìä Bot Status\n\n"
                    f"üîπ Topics Support: {'‚úÖ Enabled' if supports_topics else '‚ùå Disabled'}\n"
                    f"üîπ Active Topics: {len(self.server_topics)}\n"
                    f"üîπ Configured Servers: {len(config.SERVER_CHANNEL_MAPPINGS) if hasattr(config, 'SERVER_CHANNEL_MAPPINGS') else 0}\n"
                    f"üîπ Total Channels: {sum(len(channels) for channels in config.SERVER_CHANNEL_MAPPINGS.values()) if hasattr(config, 'SERVER_CHANNEL_MAPPINGS') else 0}\n"
                    f"üîπ Message Cache: {len(self.message_mappings)} messages\n"
                    f"üîπ WebSocket Channels: {len(self.websocket_service.subscribed_channels) if self.websocket_service else 0}\n"
                    f"üõ°Ô∏è Anti-Duplicate Protection: {'‚úÖ ACTIVE' if self.startup_verification_done else '‚ö†Ô∏è PENDING'}\n"
                    f"üîπ Topic Logic: One server = One topic ‚úÖ\n"
                    f"üîπ Startup Verification: {'‚úÖ Complete' if self.startup_verification_done else '‚è≥ In Progress'}\n\n"
                    "üìã Current Topics:\n"
                )
                
                if self.server_topics:
                    for server, topic_id in list(self.server_topics.items())[:10]:
                        exists = self._topic_exists(call.message.chat.id, topic_id)
                        status_icon = "‚úÖ" if exists else "‚ùå"
                        status_text += f"‚Ä¢ {server}: Topic {topic_id} {status_icon}\n"
                    
                    if len(self.server_topics) > 10:
                        status_text += f"‚Ä¢ ... and {len(self.server_topics) - 10} more topics\n"
                else:
                    status_text += "‚Ä¢ No topics created yet\n"
                
                markup = InlineKeyboardMarkup()
                markup.add(
                    InlineKeyboardButton("üßπ Clean Invalid", callback_data="action_cleanup"),
                    InlineKeyboardButton("üîÑ Verify Topics", callback_data="action_verify"),
                    InlineKeyboardButton("üîô Back to Menu", callback_data="action_start")
                )
                self.bot.edit_message_text(
                    status_text,
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=markup
                )
            elif action == 'verify':
                # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–ø–∏–∫–æ–≤
                self.startup_verification_done = False
                self.startup_topic_verification(call.message.chat.id)
                
                markup = InlineKeyboardMarkup()
                markup.add(InlineKeyboardButton("üîô Back to Menu", callback_data="action_start"))
                self.bot.edit_message_text(
                    f"üîç Topic verification completed!\n\n"
                    f"‚úÖ Active topics: {len(self.server_topics)}\n"
                    f"üõ°Ô∏è Duplicate protection: ACTIVE\n"
                    f"üîí No duplicates found or removed",
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=markup
                )
            elif action == 'start':
                send_welcome(call.message)
            # –î–æ–±–∞–≤–∏—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏...
            
            self.bot.answer_callback_query(call.id)

        @self.bot.message_handler(commands=['servers'])
        def list_servers(message):
            """Show interactive server list with topic info and duplicate status"""
            if not hasattr(config, 'SERVER_CHANNEL_MAPPINGS') or not config.SERVER_CHANNEL_MAPPINGS:
                self.bot.reply_to(message, "‚ùå No servers found. Please configure servers first.")
                return
                
            markup = InlineKeyboardMarkup()
            for server in config.SERVER_CHANNEL_MAPPINGS.keys():
                # Add topic indicator with duplicate check
                topic_indicator = ""
                if server in self.server_topics:
                    topic_id = self.server_topics[server]
                    if self._topic_exists(message.chat.id, topic_id):
                        topic_indicator = " üìã"
                    else:
                        topic_indicator = " ‚ùå"
                else:
                    topic_indicator = " üÜï"  # New server, no topic yet
                
                markup.add(InlineKeyboardButton(
                    f"üè∞ {server}{topic_indicator}",
                    callback_data=f"server_{server}"
                ))
            markup.add(InlineKeyboardButton("üîô Back to Menu", callback_data="action_start"))
            
            server_count = len(config.SERVER_CHANNEL_MAPPINGS)
            topic_count = len(self.server_topics)
            
            self.bot.reply_to(
                message, 
                f"üìã Select a server to view announcements:\n\n"
                f"üìä {server_count} servers configured, {topic_count} topics created\n"
                f"üìã = Has topic, ‚ùå = Invalid topic, üÜï = New server\n"
                f"üõ°Ô∏è Anti-duplicate protection: {'‚úÖ ACTIVE' if self.startup_verification_done else '‚ö†Ô∏è PENDING'}",
                reply_markup=markup
            )

        @self.bot.message_handler(commands=['reset_topics'])
        def reset_topics(message):
            """Reset all topic mappings with confirmation"""
            with self.topic_creation_lock:
                backup_topics = self.server_topics.copy()
                self.server_topics.clear()
                self.topic_name_cache.clear()
                self.startup_verification_done = False
                self._save_data()
                
            self.bot.reply_to(
                message, 
                f"‚úÖ All topic mappings have been reset.\n"
                f"üóëÔ∏è Cleared {len(backup_topics)} topic mappings.\n"
                f"üÜï New topics will be created when needed.\n"
                f"üõ°Ô∏è Anti-duplicate protection will be active."
            )

        @self.bot.message_handler(commands=['verify_topics'])
        def verify_topics_command(message):
            """Force topic verification to check for duplicates"""
            self.startup_verification_done = False
            old_count = len(self.server_topics)
            
            self.startup_topic_verification(message.chat.id)
            
            new_count = len(self.server_topics)
            removed_count = old_count - new_count
            
            self.bot.reply_to(
                message,
                f"üîç Topic verification completed!\n\n"
                f"üìä Results:\n"
                f"‚Ä¢ Topics before: {old_count}\n"
                f"‚Ä¢ Topics after: {new_count}\n"
                f"‚Ä¢ Removed/Fixed: {removed_count}\n"
                f"üõ°Ô∏è Anti-duplicate protection: ‚úÖ ACTIVE"
            )

        @self.bot.message_handler(commands=['cleanup_topics'])
        def cleanup_topics_command(message):
            """Clean up invalid topic mappings"""
            cleaned = self.cleanup_invalid_topics(message.chat.id)
            self.bot.reply_to(
                message, 
                f"üßπ Cleaned up {cleaned} invalid/duplicate topics.\n"
                f"üìã Current active topics: {len(self.server_topics)}\n"
                f"üõ°Ô∏è Anti-duplicate protection: ‚úÖ ACTIVE"
            )

        @self.bot.callback_query_handler(func=lambda call: call.data.startswith('server_'))
        def server_selected(call):
            """Handle server selection with improved topic management"""
            server_name = call.data.replace('server_', '')
            if not hasattr(config, 'SERVER_CHANNEL_MAPPINGS') or server_name not in config.SERVER_CHANNEL_MAPPINGS:
                self.bot.answer_callback_query(call.id, "Server not found")
                return
                
            # Get first announcement channel
            channels = [
                (cid, name) for cid, name in config.SERVER_CHANNEL_MAPPINGS[server_name].items()
                if not cid.startswith('telegram_')
            ]
            
            if not channels:
                self.bot.answer_callback_query(call.id, "No announcement channels found for this server")
                return
                
            channel_id, channel_name = channels[0]
            
            # Get last 10 messages and sort chronologically
            if hasattr(self, 'discord_parser') and self.discord_parser:
                messages = self.discord_parser.parse_announcement_channel(
                    channel_id,
                    server_name,
                    channel_name,
                    limit=10
                )
                
                messages.sort(key=lambda x: x.timestamp)
                
                logger.info(f"üì• Fetched {len(messages)} messages from Discord for {server_name}")
                
                if not messages:
                    self.bot.answer_callback_query(call.id, "No messages found")
                    return
                
                # Show topic status with duplicate prevention info
                topic_status = ""
                existing_topic_id = self.get_server_topic_id(server_name)
                if existing_topic_id:
                    if self._topic_exists(call.message.chat.id, existing_topic_id):
                        topic_status = f" to existing topic {existing_topic_id} (verified, no duplicates)"
                    else:
                        topic_status = " (will create new topic - old one invalid)"
                else:
                    topic_status = " (will create new topic with duplicate protection)"
                
                # Send messages using improved topic logic (prevents duplicates!)
                self.send_messages(messages)
                
                self.bot.answer_callback_query(
                    call.id,
                    f"Sent {len(messages)} messages{topic_status}"
                )
                
                # Store user state
                self.user_states[call.from_user.id] = {
                    'server': server_name,
                    'channel_id': channel_id,
                    'channel_name': channel_name,
                    'last_message': messages[-1].timestamp if messages else datetime.min
                }
            else:
                self.bot.answer_callback_query(call.id, "Discord parser not available")

        logger.success("ü§ñ Telegram Bot started with ENHANCED ANTI-DUPLICATE topic management:")
        logger.info("   ‚úÖ One server = One topic (GUARANTEED)")
        logger.info("   üõ°Ô∏è Startup verification prevents duplicates")
        logger.info("   üîí Thread-safe topic creation")
        logger.info("   üßπ Auto-cleanup of invalid topics")
        logger.info("   ‚ö° Fast cache lookup for real-time messages")
        logger.info("   üîç Duplicate detection and removal")
        logger.info("   üìä Enhanced status reporting")
        logger.info("   üöÄ Ready for real-time WebSocket messages")
        
        self.bot.polling(none_stop=True)